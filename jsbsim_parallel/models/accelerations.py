from typing import List, Optional
import torch


class AccelerationsInputs:
    def __init__(self, device: torch.device, batch_size: Optional[torch.Size] = None):
        # Use batch_size for initialization if provided, else default to a single instance.
        size = batch_size if batch_size is not None else torch.Size([])

        #The body inertia matrix expressed in the body frame
        self.J = torch.zeros(*size, 3, 3, dtype=torch.float64, device=device)
        #The inverse of the inertia matrix J
        self.Jinv = torch.zeros(*size, 3, 3, dtype=torch.float64, device=device)
        #Transformation matrix from the ECI to the Body frame
        self.Ti2b = torch.zeros(*size, 3, 3, dtype=torch.float64, device=device)
        #Transformation matrix from the Body to the ECI frame
        self.Tb2i = torch.zeros(*size, 3, 3, dtype=torch.float64, device=device)
        #Transformation matrix from the ECEF to the Body frame
        self.Tec2b = torch.zeros(*size, 3, 3, dtype=torch.float64, device=device)
        #Transformation matrix from the ECEF to the ECI frame
        self.Tec2i = torch.zeros(*size, 3, 3, dtype=torch.float64, device=device)
        #Total moments applied to the body except friction and gravity (expressed in the body frame)
        self.Moment = torch.zeros(*size, 3, dtype=torch.float64, device=device)
        #Moments generated by the ground normal reactions expressed in the body frame. Does not account for friction.
        self.GroundMoment = torch.zeros(*size, 3, dtype=torch.float64, device=device)
        #Total forces applied to the body except friction and gravity (expressed in the body frame)
        self.Force = torch.zeros(*size, 3, dtype=torch.float64, device=device)
        #Forces generated by the ground normal reactions expressed in the body frame. Does not account for friction.
        self.GroundForce = torch.zeros(*size, 3, dtype=torch.float64, device=device)
        #Gravity intensity vector (expressed in the ECEF frame).
        self.vGravAccel = torch.zeros(*size, 3, dtype=torch.float64, device=device)
        #Angular velocities of the body with respect to the ECI frame (expressed in the body frame).
        self.vPQRi = torch.zeros(*size, 3, dtype=torch.float64, device=device)
        #Angular velocities of the body with respect to the local frame (expressed in the body frame).
        self.vPQR = torch.zeros(*size, 3, dtype=torch.float64, device=device)
        #Velocities of the body with respect to the local frame (expressed in the body frame).
        self.vUVW = torch.zeros(*size, 3, dtype=torch.float64, device=device)
        #Body position (X,Y,Z) measured in the ECI frame.
        self.vInertialPosition = torch.zeros(*size, 3, dtype=torch.float64, device=device)
        #Earth rotating vector (expressed in the ECI frame).
        self.vOmegaPlanet = torch.zeros(*size, 3, dtype=torch.float64, device=device)
        #Terrain velocities with respect to the local frame (expressed in the ECEF frame).
        self.TerrainVelocity = torch.zeros(*size, 3, dtype=torch.float64, device=device)
        #Terrain angular velocities with respect to the local frame (expressed in the ECEF frame).
        self.TerrainAngularVel = torch.zeros(*size, 3, dtype=torch.float64, device=device)

        # Time step
        self.DeltaT = torch.zeros(*size, 1, dtype=torch.float64, device=device)
        #Body mass
        self.Mass = torch.zeros(*size, 1, dtype=torch.float64, device=device)

        # List of Lagrange multipliers set by FGLGear for friction forces calculations.
        self.MultipliersList: List[torch.Tensor] = []

    def to(self, device: torch.device):
        """Move all tensors to the specified device."""
        self.J = self.J.to(device)
        self.Jinv = self.Jinv.to(device)
        self.Ti2b = self.Ti2b.to(device)
        self.Tb2i = self.Tb2i.to(device)
        self.Tec2b = self.Tec2b.to(device)
        self.Tec2i = self.Tec2i.to(device)

        self.Moment = self.Moment.to(device)
        self.GroundMoment = self.GroundMoment.to(device)
        self.Force = self.Force.to(device)
        self.GroundForce = self.GroundForce.to(device)

        self.vGravAccel = self.vGravAccel.to(device)
        self.vPQRi = self.vPQRi.to(device)
        self.vPQR = self.vPQR.to(device)
        self.vUVW = self.vUVW.to(device)

        self.vInertialPosition = self.vInertialPosition.to(device)
        self.vOmegaPlanet = self.vOmegaPlanet.to(device)
        self.TerrainVelocity = self.TerrainVelocity.to(device)
        self.TerrainAngularVel = self.TerrainAngularVel.to(device)

        self.DeltaT = self.DeltaT.to(device)
        self.Mass = self.Mass.to(device)

        # Move multipliers to the device if they are tensors
        self.MultipliersList = [multiplier.to(device) for multiplier in self.MultipliersList]

class Accelerations:
    def __init__(self, device: torch.device, batch_size: Optional[torch.Size] = None):
        size = batch_size if batch_size is not None else torch.Size([])
        self.device = device

        self._in = AccelerationsInputs(device, batch_size)
        self.gravTorque = torch.ones(*size, 1, dtype=torch.bool, device=self.device)

        self.vPQRidot = torch.zeros(*size, 3, dtype=torch.float64, device=self.device)
        self.vUVWidot = torch.zeros(*size, 3, dtype=torch.float64, device=self.device)
        self.vUVWdot = torch.zeros(*size, 3, dtype=torch.float64, device=self.device)
        self.vBodyAccel = torch.zeros(*size, 3, dtype=torch.float64, device=self.device)

        #bind...todo

    def run(self, holding: bool) -> bool:
        return True

    def init_model(self) -> bool:
        #reset to IC.
        return True

    def get_pqr_idot(self):
        return self.vPQRidot

    def get_uvw_idot(self):
        return self.vUVWidot
